

第1章 程序设计


算法的概念

确定性，有穷性，可行性，输入/输出等特点
1.2 程序和程序设计

程序是指被自己算计连续执行的一条条指令的集合，是人与计算机实现沟通交流的特殊语言



2.程序的构成

（1） 声明区

声明区处在程序文件的所有函数的外部

包含头文件   #include <stream.h>
宏定义   #define PI 3.1456
类定义   class name{...};
结构体定义  struct record{...};
函数声明  void print();
全局变量声明   float H=2.05;
条件编译  #ifdef



(2) 主程序区
主程序以main()函数开始，是整个程序运行的入口，该函数中可能包含的内容有

局部变量的声明： 如 int i =1;
函数调用  如 y=sin(x);
一般运算 如 a=b+c+d/3;
结构控制  如if(a>b)c=a;
对象与结构的处理；
文件的处理等

(3)函数定义区

程序中除了main函数之外，还可以包含其他的函数，每个函数是由函数说明和函数体两个部分构成的


3.程序的书写规范


(1)  文件协定

c语言文件扩展名  .c
c++文件扩展名 .cpp
头文件扩展名.h

(2) 注释

1.注释要尽量解释概括，描述代码的功能和内容
2.文件头，函数头是注释的重点
3.每一个处理段至少有一个注释
4.全局变量，静态变量要有注释
5.每一个结构，类成员要有注释
6.对每一次修改做出记录，记录修改人，修改时间，必要时注明修改原因


4.程序设计过程应该包括分析，设计，编码，测试，排错等不同阶段


1.3  结构化程序设计

三种结构：顺序结构，选择结构，循环结构

循环结构又分为：当型循环和直到型循环

一个c语言程序总是从主函数开始执行的


第2章 数据类型及其运算

基本类型，构造类型，指针类型，无值类型

2.1 数据类型
c语言5种基本数据类型：

字符串 char
整型  int
单精度实型  float
双精度实型  double
空类型   void


c语言还提供了几种聚合类型

数组
指针
结构体 struct
共用体  union
位域
枚举 enum

2.1.1 变量，常量，标识符


1.标识符就是用来表示变量，常量，函数以及文件等的名称


2.变量 可以改变的量
变量=变量名+变量值


一个变量名实质上代表了内存中的一个存储单元，其变量值则代表了该单元存储的内容。
在程序执行过程中，通过变量名来引用变量值


3. 常量


常量分为，数值型常量，字符型常量。
数值型常量又分为整型常量和实型常量


符号常量

c语言用一个标识符表示一个常量，称为符号常量

定义符号常量的一般形式为   #define 标识符   常量


2.1.2  基本数据类型


[signed] int 
unsigned [int]
[singed] short [int]
unsigned short [int]
[sigened] long [int]
unsigend long [int]

float 
double
long double

字符型数据

1. 字符常量
就是用一对单引号括起来的单个字符


2.字符串常量

是用双引号扩括起来的0个或多个字符组成的序列
存储：每个字符串尾部自动加一个'\0'作为字符串结束表示。
字符串常量占用的字节数是字符串的总长度加1


3.字符变量

字符型的定义形式   char 变量名1(=初值)(，变量名(=初值2)..);


4. 字符变量的运算

字符串的连接就是将两个字符串连接在一起. "AB"+"CD"="ABCD";



4.数据类型之间的转换

不同数据类型之间运算，首先要将其转换为相同的类型，c语言类型转换分级别，一般是
(1) 低级向高级转换，需要以下规则


1.若参与类型运算量的不同，则先转换成同一类型，然后进行运算
2.转换按数据长度增加的方向进行，以保证精度不降低
3.所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double 型
4.char型和short型参与运算时，必须先转换成int型
5.在c语言的赋值表达式中，赋值号右边的值先转换成与赋值号左边的变量相同的类型后
再记性赋值

(2) 若高级向低级转换，要到强制类型转换符
(类型说明符)(表达式) 

int(7.7) =7;


运算符和表达式


算术运算符


+ - × 、 - % ++ --

算术运算符优先级   括号>取负值>乘除运算>加减运算

赋值表达式 =


1. 一般形式  变量=表达式
2. 复合赋值

变量  运算符=(表达式)
等价于

变量=变量 运算符(表达式)


3. 赋值运算的数据类型转换


当赋值号左边的变量为短整型，右边的值为长整型时，短整型变量只能接受长整型数值低位上
对应字节(即两个字节)中的数据，相应的，高位上的数据将丢失！


2.2.3  自增，自减运算符

1.前缀形式(++k,--k)


若 int k=6;

若表达式为++k,先进行k增1的运算，k的值为7，表达式的值也为7；
若表达式为--k,则先进行k减1的运算，k的值为5，则表达式的值也为5


2.后缀形式(k++,k--)

若表达式为k++,则表达式先取k的值为6，然后k自行增1运算，使k的值为7
若表达式为k--,则表达式先取k的值为6，然后k自行减1运算， 使k的值为5


2.2.4  逻辑运算符和逻辑表达式


逻辑与  &&
逻辑或 ||
逻辑非  !

关系运算符  < > <= >= == !=


条件运算符 ?


表达式1? 表达式2：表达式3

运算过程：先求解表达式1，若其值为真（非0），则将表达式2的值作为整个表达式的取值；
若表达式1的值为假（0），则将表达式3的值作为整个表达式的取值

max =(a>b)? a:b


优先级

条件运算符 优先级高于赋值，逗号运算符，低于其他运算符

条件运算符具有结合性
右近原则
当一个表达式中出现多个条件运算时，应该将位于最右边的问号与离它最近的冒号配对，
并按这一原则正确区分各条件运算符的运算对象

逗号运算符和逗号表达式，
可以用来连接多个比倒是



第3 章 

表达式；


函数名(实际参数表)；


空语句

while(getchar()!="\n");

符合语句{语句1，语句2,...}


控制语句博爱看

选择，循环，转向和返回
if else switch

while do...while  for 


break continue goto

return


scanf函数是格式输入函数，即按用户指定的格式从键盘上把数据输入到指定的变量之中

scanf("格式说明字符串",变量地址);


%d 十进制证书
%c 单单字符
%f 浮点数

%s 读字符串


% + 附加格式字符+格式字符



变量地址需要的不是变量本身，而是变量的存储地址。
必须在变量a之前加取地址运算符，"&" &a表示变量a在内存中的地址


在%和格式字符之间加入*号，作用是跳过对应的输入数据

在格式字符前加入一个正整数指定输入数据所占的宽度



printf函数是格式化输出函数，一般用于向标准设备按规定格式输出信息，
printf("格式化字符串",参量1，参量2);


% + 附加格式字符 + 格式字符

printf的输出格式为自由格式，两个书之间是否留逗号，空格或回车，
完全取决于格式控制


getchar是字符输入函数，就是从标准输入设备(键盘)上输入一个字符，
直到回车才结束，回车前的所有输入字符都会之歌显示在屏幕上

getchar();

务必在程序(或文件)的开头加上编译与预处理命令(也称为包含命令)
#include<stdio.h>

putchar函数是字符输出函数，作用是向终端输出一个字符

putchar(ch);


其中ch可以是一个字符变量或常量，也可以是一个转义字符。



1.putchar函数的作用是向终端输出一个字符

只能用与单个字符的输出，且一次只能输出一个字符

使用putchar函数时，一定要在程序或文件的开头加上编译预处理名 #include<stdio.h>



第4章  选择结构程序设计

if(表达式)
	语句



if(表达式)
	语句1；
else
	语句2；



if-else-if形式

if(表达式1)
	语句1；
else if(表达式2)
	语句2；
	else if(表达式3)
	语句3；


处理多个分支的情况

if语句的嵌套

if(表达式)
	if语句；

或

if(表达式)
	if语句；
else
if语句；

c语言规定else总是与它前面最近的if配对


用switch实现多分支


switch(表达式)
{
case 常量表达式1：语句1；

default:语句n+1;
}


c语言还提供了一种break语句，专用于跳出switch语句，break语句没有参数



循环结构程序设计


for (语句1;语句2；语句3；)
{循环体}


语句1  是循环变量赋初值，它总是一个赋值语句，用来给循环控制变量赋初值
语句2 是循环条件，它是一个关系表达式，决定什么时候退出循环
语句3 是循环变量变量增量，它定义循环控制变量每循环一次后按什么方式变化

注意，表达式是可选项
省略表达式1， 循环变量赋初值，表示不对循环控制变量赋初值
省略表达式2， 循环条件，则不做其它处理时成为死循环
省略表达式3， 循环变量增量，则不对循环控制变量进行操作，这时可以在语句体中加入修改循环控制变量的语句


for(i=1;i<=100;i++)
sum=sum+i;


for(i=1;i<=100;)
{sum=sum=i;i++;}


while(表达式)
语句；

while 语句的说明

while语句中的表达式一般是关系表达式或逻辑表达式，只要表达式的值为真(非0)即可继续循环

循环体如包含有一个以上的语句，则必须用{}括起来，组成复合语句


do 
 语句
while(表达式)；

它先执行循环中的语句，然后再判断表达式是否为真，如果为真则继续循环，入股为假则终止循环。
do-while循环至少要执行一次循环语句

continue 作为结束本次循环，而不终止整个循环的执行

跳过循环体下面尚未执行的语句，接着进行下一次是否执行循环的判断


break 还可以用在switch语句中，用来跳出switch语句m
当break语句用于do-while,for,while循环语句中，可使程序终止循环而执行循环后面的语句


循环嵌套是逻辑程序中常用的一种方法，就是在一个循环体语句中又包含另一个循环语句，
循环嵌套后，实际上就构成了多层循环，每次执行一次外循环，内层循环都要从头到尾执行一遍


void 是无类型，对应的 void* 无类型指针

常用在程序编写中对定义函数的参数类型，返回值，函数中指针类型进行声明

void作用
1.对函数返回的限定
当函数不需要返回值时，必须使用void限定
例如， void func(int a, char*b)

2.对函数参数的限定

当函数不允许接受参数时，必须使用void限定

例如，int func(void)


数组的定义和引用

在c语言中，数组属于构造数据类型
又分为数值数组，字符数组，指针数组，结构数组等


一维数组是最简单的数组，其逻辑结构是线性表。
一维数组的每个元素只带有一个下标，下标表示了元素在数组中的顺序号

类型名 数组名[常量表达式];


类型名  是任一种基本数据类型或构造数据类型
数组名是用户定义的数组标识符
方括号中的常量表达式表示数据元素的个数，也称数组的长度

int x[1];

存储样式，每个元素只有一个下标，c语言规定每个数组第一个元素的下标总为0(称为数组下标的下界)
最后一个元素的下标为数组个数减1(称为数组下标的上界)


一维数组初始化


给数组赋值的方法除了用赋值语句对数组元素诸葛赋值外，还可以初始化赋值和动态赋值的方法


数组初始化赋值是指在数组定义是给数组元素赋予初值

类型名  数组名[常量表达式] ={值，。。}



int x[10] = {0,1,2,3,4,5,6,7,8,9}


1 可以之分部分元素赋初值
2. 只能给元素逐个赋值，不能给数组整体赋值
3.如果给全部元素赋值，则在数组说明中，可以不给出数组元素的个数

int x[] = {1};


一维数组的引用

数组元素是组成数组的基本单位，数组元素也是一种变量，其标识方法

数组名后跟一个下标，其中下标只能为整型常量或整型表达式，为小数时c编译将自动取整

x[5]
x[i+j]
x[i++]


数组元素通常也称为下标变量。必须先定义数组，才能使用下标变量。
在c语言中之恩给你逐个使用下标变量，而不能一次引用整个数组。
for(i=0;i<10;i++)
printf("%d",x[i])


二维数组

c语言允许构造多为数组

多维数组有多个下标，以标识它在数组中的位置，


类型名  数组名[常量表达式1][常量表达式2]

int a[3][4]


二维数组在概念上是二维的的，但是实际的硬件存储器却是连续编址的，
存储器单元是按一维线性排列的，如何在一维存储器中存放二维数组，
有两种方式：
1.一种是按行排列，即放完一行之后顺次放入第二行
2. 按列排列，即放完一列之后再顺次放入第二列


在c语言中，二维数组是按行排列的，即先放a[0]行，再存放a[1]行，最后存放a[2]行

由于数组a为int类型，该类型占两个字节的内存空间，所以
每个水元素均占两个字节。

二维数组初始化 也是在类型说明时各喜爱报变量赋以初值

数据类型 数组名[行下表达式][列下标表达式] ={{第0行初值表}，{第1行初值表}};


1.初值表中的数据可以少于数组元素的个数。
这时编译器将按数组元素在内存中的排列顺序，将初值表中的数据一一赋予各个元素，而其他元素
将被赋值为0

2. 二维数组可按行分段赋值，也可以按行连续赋值

3. 数组初始化时，行下标表达式可以省略不写，但列下标表达式不嗯给你不谢


二维数组的引用


二维数组的元素也称为双下标变量
数组名[下标][下标]

其中下标应为整型常量或整型表达式

a[3][4]表示  数组三行四列的元素

数组说明的方括号中给出的是某一维的长度，即可取下标的最大值
而数组元素中的下标是该元素在数组中的位置标识。
前者只能是常量，后者可以是常量，变量或表达式

字符数组与字符串


字符数组，用来存放字符量的数组，可以有一维字符数组，二维字符数组，形式与前面介绍的数值数组相同

char c[10];


由于字符型和整型通用，也可以定义为  int c[10]

但这时每个数组元素占2个字节的内存单元

字符数组也可以是二维或多维数组

char c[5][6];

字符数组也允许想数值数值那样定义初始化赋值，
但字符数组与字符串的赋值方法有区别


char c[5] = {'b'};
char c[5] ="6";


字符数组与字符串的输入输出

c语言提供了%c和%s 这两种格式符来进行字符数组的输入和输出。

其中格式符"%c"用于单个字符的输入和输出
格式符"%s"用于整串字符的输入和输出


char a;
char b[20];
scanf("%c",&c);
scanf("%s",b)


字符串处理函数

字符串的输入，输出，合并，修改，比较，转换，复制，搜索


用于输入输出的字符串函数，在使用前应包含头文件"stdio.h"
使用其他字符串函数则应包含头文件"string.h"


1. 字符串输出函数puts
puts(字符数组名)
把字符数组中的字符串输出到显示器上，即在屏幕上显示该字符串

puts函数可以由printf函数取代

当需要按一定格式输出时，通常还是用prinf函数

2.字符串输入函数 gets
gets(字符数组名)
从标准输入设备键盘上输入一个字符串

本函数得到一个函数值，即为该字符数组的首地址


gets函数并不以空格作为字符串输入结束的标志，
而只以回车作为输入结束

3. 字符串连接函数strcart

strcat(字符数组名1，字符数组名2)

把字符数组2中的字符串连接到字符数组1中字符串的后面，并删去字符串1
后的串标志"\0" 本函数返回值是字符数组1的首地址


本程序吧初始化赋值的字符数组与动态赋值的字符串连接起来
字符数组1应定义足够额长度，否则不能全部装入被连接的字符串


4.字符串拷贝函数strcpy
strcpy(字符数组名1，字符数组名2)
把字符数组2中的字符串拷贝到字符数组1中。
串结束标志"\0"也一同拷贝
字符数名2，也可以是一个字符常量。
这时相当于把一个字符串赋予一个字符数组

本函数要求字符数组1有足够的长度，否则不能全部装入所拷贝的字符串

5. 字符串比较函数strcmp
strcmp(字符数组名1，字符数组名2)

按照ASCII码顺序比较两个数组中的字符串， 并由函数返回值返回比较结果

字符串1=字符串2， 返回值=0;
字符串1>字符串2， 返回值>0;
字符串1>字符串2， 返回值<0;

6. 测字符串长度函数strlen

strlen(字符数组名)

测字符串的实际长度(不含字符串结束标志\0)并作为函数返回值

c语言的数组总结


三种赋值

初始化赋值
输入函数动态赋值
赋值语句

对数值数组不能用赋值语句整体赋值，输入或输出，而必须用循环语句逐个对数组元素进行操作

1.数组的类型实际上是指数组元素的取值类型。对于同一个数组，其所有元素的数据类型都是相同
2.数组名的书写规则应符合标识符的书写规定
3.数组名不能与其变量名相同


一维数组在内存中所占的字节数为：数组长度 × sizeof(元素类型)


二维数组的物理存储结构为一维，
即按行序顺序存储在连续存储空间中
例子中，p为指向数组元素的指针变量，初始时，p指向a[0][0]
通过指针p实现对二维数组元素按行i


字符数组中所存字符中有'\0'时，字符数组才能作为字符串使用

char s[] = {'1','2','3','\0'}

用字符常量对字符数组初始化，且最后一个元素的值为字符串结束标志('\0')
所以数组s中存放的就是字符串"123"


char s[] = {"123"}

直接使用字符串"123"对字符数组初始化


char s[4] = {'1','2','3'}

用字面常量对部分元素初始化，系统为第4个元素负初值为空,即'\0'
这样也是可以的！

第7章 函数

库函数的正确使用
函数的定义和使用方法
函数的类型和返回值
形式参数与实在参数，参数值的传递

函数的正确调用，嵌套调用，递归调用

7. 库函数


库函数(library function) 就是把函数放到库里工别人使用的一种方法。
c语言的库函数是由编译程序根据用户的需要提供给用户的额一组程序
c语言是一种结构化程序设计语言，而结构化程序设计的总体思想是采用模块化结构
用函数实现功能模块的定义，然后通过函数之间的调用来实现程序功能
c语言的函数有两种：
1.库函数(标准函数，c语言自带)，用户可以直接调用
2.自定义函数，由用户根据使用的目的自己设计


1.调用函数需要的include明星

在调用库函数时，必须用include命令来包含头文件名，
#include<math.h>

注意：include命令必须以"#"号开头，文件名用一对双引号""或一对尖括号<>括起来；
系统提供的头文件是以.h作为文件后缀


2.库函数的调用

函数名(参数表)

2种调用方式

（1） 出现在表达式中

y=pow(x,8)+1;

(2)作为独立的语句完成某种操作

printf("%d",a[i]);

在printf函数调用后加一个分号，构成了一条独立的语句，实现输出的具体操作


3. 常用的库函数

(1) I/O函数
getchar,putchar,printf,scanf,fopen,fclose,fgetc,fgets,fprintf,
fscanf,fputc,fputs,fseek,fread,fwrite等

（2） 字符串，内存和字符函数
用于检查字符的函数
isalnum,isalpha,isdigit,islower,isspace等

用于字符串操作函数
strcat,strchr,strcmp,strcpy,strstr等


（3） 数学函数

需要的包含文件:math.h

sin,cos,exp(e的x次方)，
log,sqrt(开平方)，pow(x的y次方)等


(4) 时间、日期和系统有关的函数

需要的包含文件：time.h
例如：time返回系统的时间；asctime返回以字符串形式表示的日期和时间

使用库函数注意：
1.需要使用的包含文件
2。函数参数的类型及顺序
3.函数返回值意义
4.函数的功能


7. 2  函数的定义方法

1. 无参数函数的定义形式

类型标识符  函数名()
{
	声明部分
	语句
}

其中类型标识符和函数名称称为函数头。
类型标识符指明了函数的类型，函数的类型实际上是函数返回值的类型；
函数名是由用户定义的标识符，函数名后有一个空括号，其中无参数，
{}中的内容为函数体，在函数体中声明部分，是对函数体内部所用到的变量的类型说明


在很多情况下都不要求无参数函数有返回值，此时函数类型符可以写为void


void Hello()
{
	printf("Hello world \n");
}


Hello函数是一个无参数函数，当被其他函数调用时，输出Hello world字符串

2. 有参数函数定义的一般形式

类型标识符  函数名(数据类型 形式参数1，数据类型 形式参数2,)

{	
	声明部分
	语句
}

在进行函数调用时，主调函数将赋予这些形式参数实际的值，另外需要注意的是：
形参既然是变量，必须在形参中给出形参的类型说明

在c中，一个函数的定义可以放在任意位置，既可以放在主函数main之前，也可以放在main之后

int max(int a,int b)
{
	if(a>b) return a;
	else return b;
}

main()
{
	int max(int a,int b);
	int x,y,z;
	printf("input two numbers:\n");
	scanf("%d%d",&x,&y);
	z=max(x,y);
	printf("maxmum=%d",z);
}


7.3 函数返回值


函数返回值是一个函数在运算结束以后向调用它的母函数或系统反馈一个值，
这个值可以是各种变量类型。通常用return语句来实现返回，
return 表达式或return(表达式)；

int add(int a,int b)
{
	return(a+b)
}
	int main()
{
	int res;
	res= add(3,4);
	printf("%d",res);
	return 0;
}


7.3 函数返回值

函数返回值是一个函数在运算结束以后向调用它的母函数或系统反馈一个值，
这个值可以是各种变量类型。
通常用return 语句来实现返回，return语句将的到给调用它的main函数供其使用，
而在main中，返回值被用于给res赋值

注意：
1.return语句的圆括号可以省略
2.程序最终输出数据的类型以函数类型为准
3.可以用"void"定义函数返回值为“空类型”
4.表达式的类型要与函数首部所说明的类型一致


7.4 函数的声明

c语言编译系统是由上往下编译的，一般被调函数放在主调函数后面时，前面需要声明，
否则c由上往下的编译系统将无法识别。
正如变量必须先声明后使用一样，函数也必须在被调用之前先声明，否则无法调用
函数的声明可以与定义分离，要注意的是一个函数只能被定义一次，但可以声明多次

7.4.1 函数声明定义

函数声明也称为函数模型（或函数原型）由函数返回类型，函数名和形参列表组成。
形参列表欧必须包含形参类型，但不必对形参命名。

函数返回类型  函数名(参数1类型 参数1，参数2类型 参数2,..);

函数声明只是对编译系统的一个说明
1.函数声明是对定义的函数的返回值的类型说明，以通知系统在本函数中所调用的函数的类型
2. 不包含函数体(或形参)
3.调用几次该函数就应在各个主调函数中做相应声明
4.函数声明是一个说明语句，必须以分号结束
5.一个完整的程序中，函数声明语句要与函数调用表达式在同一个文件中，并且函数声明语句出现在前，
函数的调用出现在后
6.并不是对所有被调用函数都要声明


7.4.2 函数声明的位置

1.在调用的函数前定义函数，此时可以不需要声明
2.在调用的函数前调用
3.在调用的函数里面也可以声明
4.在其他文件的头文件*.h文件里面声明，*.c文件可直接调用头文件


7.5  形参，实参及参数传递


在函数的定义和说明语句中，将函数名后面括号内的参数称为"形式参数"
在函数的调用语句中，将函数名后面括号内的参数称为实际参数


当函数被调用时，主调函数通过实参向被调用函数的形参传递数据，函数调用
并完成一定的功能后，也要向主调函数返回一些数据

被调用函数的形参应确定数据类型，而在函数调用时，实参的数据类型应与形参一致。

下面几种函数间的数据传递方式

1. 值传递方式

当形参为变量而实参为变量，某个数据元素，常量或表达式时，在函数调用过程中数据传递通常使用
的是值传递方式


在程序执行中，系统会给形参和实参分别分配内存单元，在函数调用时，程序将实参的值传递给形参
存在系统分配内存单元中，供被调用函数使用；
函数执行完毕，形参不将处理后的值返回给实参，实参的值不变，被调用函数只能通过return语句
返回一个值给主调函数，形参的内存单元被释放

通过吧主调函数中被调用函数名后的实参(x,y)赋值给被调用函数的形参(a,b)，由被调用函数进行处理
从而实现主调函数与被调用函数减数据的传递。

2. 地址传递方式

当函数被调用时，被调用函数的形参和实参为指针变量或数组时，函数间的数据传递使用的是地址传递方式

在程序的执行过程中，系统给实参分配存储空间，在函数调用时，将实参获得的存储空间的地址传递给形参
使形参指向同一存储空间，实参指向存储空间的值被处理

被调用函数执行完毕返回主调函数时，由于形参和实参指向同一存储空间，形参指向的存储空间的值
的变化也就是实参指向存储空间的值的变化，从而实现被调用函数返回多个值个主调函数，形参的内存单元
被释放。
在此程序中，通过把主调函数中被调用函数名后的实参(即变量的值)赋值给被调用函数的形参(变量)，
由被调用函数进行处理，从而实现主调函数与被调函数间数据的传递
在这种数据传递方式中，函数最多只能返回一个值

3. 全局变量传递方式

全局变量是指在函数之外定义的变量。
如果在函数之外定义了全局变量，则该变量的作用域从变量的定义位置开始到本源程序内文件结束，
在其作用域中，任何函数均可以使用全局变量

在全局变量的作用域中，如某一函数改变了全局变量的值，则在其后使用的是改变后的全局变量的值。
由于全局变量定义以后，其作用域中的函数都可以使用它，从而也可以实现函数间数据的传递

在此程序中，变量Max,Min是全局变量，既可以在主函数中使用，也可以在被调用函数average中使用，
在average函数中获得的值可以在主函数中输出

全局变量不宜过多，在程序中应尽量不使用全局变量


7.6 函数的调用


在c语言中，通过函数实现模块化程序设计思想，即用函数实现功能模块的定义，然后
通过函数之间调用来实现程序功能。
程序宏的函数根据其在某个程序中的使用方式的不同，又分为主调函数和被调用函数


7.6.1 函数调用的一般形式


c语言中，函数调用的一般形式是
函数名(数据类型 实际参数1，数据类型  实际参数2);

实际参数可以是常数，变量，表达式等，多个实际参数用逗号分隔

7.6.2 函数的嵌套调用

c语言中不允许作嵌套的函数定义
因此个函数之间是平行的，不存在上一级函数和下一级函数的问题
c语言允许在一个函数的定义中出现对另一个函数的调用。
这样就出现了函数的嵌套调用，即在被调用函数中又调用其他函数

7.6.3  函数的递归调用

一个函数在它的函数体内调用它自身称为递归调用。
这种函数称为递归函数
c语言允许函数的递归调用，
在递归调用中，主调函数又是被调用函数。
执行递归函数将反复调用其自身，每调用一次就进入新的一层，是函数嵌套的一个特例
常用的办法是加条件判断，满足某种条件后就不再作递归调用，然后逐层返回

c语言的基本组成就是函数

形式参数不可以回传实际参数

用户调用标准库函数前不需要成功重新定义，只需要使用预编译命令将该函数所在
文件包括用户源文件中即可
系统允许用户重新定义标准库函数，但此时该函数将失去原有含义


main()函数可以出现在任何地方


若在c语言中未说明函数的类型，则系统默认该函数的数据类型是int型

形参一定是变量，参数传递的过程可以看做是赋值的过程

局部变量会在作用范围外失效，因为它的内存已经不存在了

形参和实参的类型必须要一致，当形参和实参不是指针类型时，在该函数运行时，
形参和实参是不同的变量，他们在内存转给你位于不同的位置，
形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不糊改变
而如果函数的参数是指针类型变量，在调用该函数的过程中，传给函数的是实参的地址，
在函数体内部使用的也是实参的地址，即使用的就是实参本身
所以在函数体内都可以改变实参的值

形参，是在函数的定义中，放在括号里声明的变量；实参，是调用函数时，
传入的参数。数组在进行形参实参结合的时候，就是传递数组的首地址
并不是把整个数组拷贝一份放入函数里运行


在c语言中，字符'\0'标识一个字符串的结尾。
在字符串中，只要遇见字符'\0',
就标志着字符串已经结束，其后面的字符已经不属于当前字符串



第8章 变量及其作用域和生存期

局部变量和全局变量的定义及作用域
变量的存储类别(自动，静态，寄存器，外部)，函数的存储分类


8.1  c程序的内存分布


c程序有5部分组成


1. 正文段 ----CPU执行的及其指令部分；
一个程序只有一个副本；只读，防止程序由于意外事故而修改自身指令；

2. 初始化数据段(data段)---在程序中所有赋了初值的全局变量，存放在这里

3. 非初始化数据段(bss段)----在程序中没有初始化的全局变量；内核将此段初始化为0

4. 栈----增长方向：自顶向下增长；自动变量以及每次函数调用时所需要保存的信息(返回地址，环境信息)

5.堆---动态存储区，是向高地址扩展的数据类型，是自下而上的扩展方式


变量是存储在栈区或堆区或bss段或data段等不同的存储域，变量定义在不同的地方说明它们有着不同的作用域

8.2 局部变量和全局变量
形参变量只是在被调用期间才分配内存单元，调用结束立即释放。
这一点表明形参变量只有在函数内才是有效的，离开该函数就不再使用了。


这种变量有效性的范围称为变量的作用域。不仅对于形参变量，c语言中所有的量都有自己的作用域

变量说明的方式不同，其作用域也不同。
c语言中的变量，按变量的作用域(空间)角度来分，可以分为局部变量和全局变量；
从变量值存在的作用时间(生存期)角度来分，可以分为静态存储方式和动态存储方式


8.2.1  局部变量


也称为内部变量。局部变量是在函数内作定义说明的，其作用域仅限于函数内，离开该函数后再使用这种变量是非法的


1. c语言中，主函数与其他函数是平行关系，在主函数中定义变量也只能在主函数中使用，不能在其他函数中
使用。同时，主函数中也不能使用其他函数中定义的变量


2.形参变量是属于被调函数的局部变量，实参变量是属于主调函数的局部变量


3.允许在不同的函数中使用相同的变量名，它们代表不同的对象，分配不同的单元，互不干扰，也不会发生混淆


4. 在复合语句中也可以定义变量，其作用域只在复合语句范围内


8.2.2 全局变量


全局变量也称为外部变量，它是在函数外部定义的变量。
它不属于哪一个函数，它属于一个源程序文件，其作用域是整个源程序。

在函数中使用全局变量，一般应作全局变量说明，全局变量的说明符为extern 
但在一个函数之前定义的全局变量，在该函数内使用可不再加以说明


全局变量与局部变量同名

1.如果同一个源文件中，全局变量与局部变量同名，则在局部变量的作用范围内，外部变量被"屏蔽"，即它不起作用
2. 全局变量的作用域从定义开始直到本文件结束，一般全局变量的定义放在文件开始位置

3. 全局变量会加强函数之间的数据联系，不利于提高函数的独立性


8.3  变量的存储类别

8.3.1  动态存储方式与静态存储方式

静态存储方式：是指在程序运行期间分配固定的存储空间的方式
动态存储方式：是在程序运行期间根据需要进行动态的分配存储空间的方式

在程序开始执行时给全局变量分配存储区，在程序执行过程中它们占据固定的存储单元，
而不动态地进行分配和释放，因此局部变量既可以说明成自动类，也可以说明成静态类，
而全局变量只能是静态类


存储说明符:
auto 自动
register 寄存器
static 静态
extern 外部

这些说明符通常与类型名一起出现，它们可以放在类型名的左边，也可以放在类型名的右边


auto int i,j;

int auto i,j;

8.3.2 auto变量

函数中的局部变量，如果不专门声明为static存储类别，都是动态得分配存储空间，函数中的
形参和在函数中定义bianl(包含在复合语句中定义的变量)都属于此类。

在调用该函数时系统会给它们分配存储空间，在函数调用结束时就自动释放这些存储空间

这类局部变量称为自动变量，自动变量用关键字auto作存储类别的声明

8.3.3  static变量

1. 全局静态变量

在全局变量之前加上关键字static,全局变量就被定义成为一个全局静态变量

(1) 内存中位置：静态存储区（ 静态存储区在整个程序运行期间都存在）
(2) 初始化：未经初始化的全局静态变量会被程序自动初始化为0
(3) 作用域：全局静态变量在声明他的文件之外是不可见的，准确地说明从定义它的函数或语句块结束的时候，
作用域随之结束


注意

(1) 当static用来修饰局部变量的时候，它就改变了局部变量的存储位置，从原来的栈中存放
改为静态存储区。但局部静态变量在离开作用域之后，并没有被销毁，
而是直到程序结束都驻留在内存当中，只不过我们不嗯给你再对他进行访问

(2) 当static用来修饰全局变量的时候，它就改变了全局变量的作用域(在声明它的文件之外是不可见的)
但是没有改变它的存放位置，还是在静态存储区中

3. 定义 静态函数的好处

(1) 其他文件中可以定义相同名字的函数，不会发生冲突
(2) 静态函数不能被其他文件所用

8.3.4  register 变量

c语言允许将局部变量的值放在CPU中的寄存器中，这种变量叫做寄存器变量
与auto变量的区别在于：
用register说明变量是建议编译程序将变量的值保留在CPU的寄存器中，而不是像一般变量那样占内存单元。
程序运行时，访问存于寄存器的值要比访问存于内存中国你的值快得多。

1.只有局部自动变量和形式参数可以作为寄存器变量
2.一个计算机系统中的寄存器数目有限，不能定义任意多个寄存器变量
3. 局部静态变不能定义为寄存器变量


8.3.5  extern 变量

全局变量可以使用static和extern

extern 说明的全局变量具有的基本特点
1. 内存分配：编译时，将其分配在静态存储区，程序运行结束释放存储单元
2.变量的初值：若定义变量时未赋初值，在编译时系统自动赋初值为0
3.生存期： 整个程序的执行期间

当一个程序由多个编译单元组成，并且在每个文件中均需要引用同一个全局变量时，
若在每个文件中都定义一个所需的同名全局变量，则在"连接"时会发生"重复定义"的错误
在这种情况下，单独编译每个文件时并无异常，编译程序将按定义分别为它们开辟存储空间；
而当进行连接时，就会显示出错信息，指出同一个变量名进行了重复定义

解决办法：
在其中一个文件中定义所有全局变量，而在其他用到这些全局变量的文件中用extern对这些变量进行声明，
声明这些变量已在其他编译单元中定义，通知编译程序不必再为它们开辟存储单元。


8.4  函数的存储分类

8.4.1  内部函数

在一个源文件中定义的函数只能被本文件中的函数调用，而不能被同一源程序其他文件 中的函数调用，
这种函数称为内部函数。

static 返回值的类型 函数名(形式参数列表)
{}

内部函数也称为静态函数。静态函数的特征是：只限于本编译单位的其他函数调用它，而不允许
其他编译单位中的函数对它进行调用。
使用静态函数，可以避免不同编译单位因函数同名而引起混乱
若强行调用静态函数，将产生出错信息

8.4.2 外部函数

当定义一个函数时，若在函数返回值的类型前加上说明符"extern"时，称此函数为外部函数。
外部函数在整个源程序中都有效，

extern 返回值的类型 函数名(形式参数表)
{}

外部函数的特征是：可以被其他编译单位中的函数调用。
通常，当函数调用语句与被调用函数不在同一编译单位，且函数的返回值为非整型时，应该
在调用语句所在函数的说明部分用extern 对所调用的函数进行函数说明


c语言变量的有效范围仅限于包含它的最近的大括号内，所以说在符合语句中
定义了一个变量它的有效范围也仅限于该复合语句中

如果要限制一个变量只能为本文件所使用，必须通过静态外部变量来实现


外部变量在以编译时由系统分配永久的内存空间，所以外部变量的类型不是自动存储类别

只有在使用时才为该类型变量分配内存的存储类说明是auto,regiter

第9章 指针

地址，指针变量，地址运算符，间址运算符

一维，二维数组和字符串的地址以及指向变量，数组，字符串，函数，结构体
的指针变量的定义。通过指针引用以上各类型数据

用指针作为函数参数
返回地址值的函数

9.1 地址与指针变量

指针(Pointer)是编程语言中的一个对象，利用地址，它的值直接指向存储在电脑存储器中的
另一个地方的值。
由于听过地址能找到所需的变量单元，地址指向该变量单元。将地址形象化为指针
通过它能找到以它位地址的内存单元


1. 内存地址

计算机内存中每个字节对应的各个存储单元都是有序的，按字节编码，"编号"就是存储单元的“地址”
2. 数据在内存中的存储及读取


c语言中有两种内存单元访问方式，分别是

内存单元直接访问和内存单元间接访问

1. 直接访问是根据变量的地址来访问变量的值，printf语句
printf(“%d”,a);

一个字符型的变量分配1个字节的存储空间，

1个字符型变量  1字节
整型  4个字节
浮点型 4个字节

2.间接访问
内存单元的间接访问就是将变量a的地址放到另一个变量p中，这个变量p的值就是变量a的地址


3.指针和指针变量

变量的指针就是变量的地址，指针变量就是存放地址的变量，通过"指针"可以找到以它为地址的内存单元

专门用来存放变量地址的变量，称为"指针变量"。即c语言中，允许用一个变量来存放指针，
这种变量称为称为指针变量。因此，一个指针变量的值就是某个变量的地址或某变量的指针

9.2  指针变量


指针类型说明符  *指针变量名；

其中"*"表示这是一个指针变量，"指针变量名"即为定义的指针变量名，
"指针类型说明符"表示 本指针变量所指向的变量的数据类型
int *pl;

表示pl是一个指针变量，它的值是某个整型变量的地址；
或pl指向一个整型变量。
至于pl究竟指向哪一个整型变量，应由向pl赋予的地址来决定


9.2.2  指针变量的应用


指针变量通普通变量一样，使用之前要定义说明，而且必须赋予具体的值。

指针变量的赋值只能赋予地址，决不能赋予任何其它数据，否则将引起错误

在c语言中，变量的地址是由由编译系统分配的，对用户完全透明，
用户不知道变量的具体地址


1  &取地址运算符

取地址运算符是单目运算符，其结合性为自右至左，其功能是取变量的地址。
在scanf函数中我们已经了解并使用的 &运算符

&变量名；


int a;
p_int = &a;


2. *指针运算符("间接访问"运算符)

指针运算符是单目运算符，其结合性为自右向左，用来表示指针变量所指的变量。

在指针运算符之后的变量必须是指针变量


*变量名；

int a;
int  *p=&a;  把整型变量a的地址赋予整型变量的指针变量p*
*p_ch ='a';   将 'a'存储在p_ch所指向的地址中，也就是ch的地址*


其中，语句*p_ch='a';的效果等价于 ch='a'
带指针运算符的语句采用的是间接内存操作，后面的语句则是直接内存操作

指针运算符"*" 和指针变量说明中的指针类型说明符"*"不是一回事

在指针变量说明中，"*"是指针类型说明符，表示其后的变量是指针类型
而表达式中出现的"*" 则是一个运算符，用以表示指针变量所指向的变量

9.2.3  指针变量的运算符

1. 赋值运算符

指针变量的赋值运算符的几种形式

（1） 指针变量初始化赋值，
（2） 相同类型变量之间的赋值

把一个变量的地址赋予指向相同数据类型的指针变量

把一个指针变量的值赋予指向相同类型变量的另一个指针变量

把数组的首地址赋予指向数组的指针变量

数组名表示数组的首地址，故可赋予指向数组的指针变量
数组第一个元素的地址也是整个数组的首地址

也可以采用初始化赋值的方法

把字符串的首地址赋予指向字符类型的指针变量

用初始化赋值的写法 并不是把整个字符串装入指针变量，而是吧存放该字符串的
字符数组的首地址装入指针变量

把函数的入口地址赋予指向函数的指针变量

（3） 给指针变量赋空值

因为指针变量必须要在使用前进行初始化，当指针变量没有指向的对象时，
也可以给指针变量赋NULL值，这个值为空值

NULL是在stdio.h头文件中定义的预定义符，因此在使用NULL时，
应该在程序的前面出现预定义命令行

2. 加减算术运算符

指针变量加或减一个整数n的意思：
把指针指向的当前位置向前或向后移动n个位置。
它指向的变量所占的内存单元的字节数为单位进行加减的，
整型指针 每次移动4个字节
浮点型  4个字节
字符型指针每次 1个字节


数组指针变量向前或向后移动1个位置和地址加减1概念是不同的
因为数组可以有不同的类型，各种类型的数组元素所占的字节长度是不同的。
如指针变量加1，即向后移动1个位置表示指针变量指向下一个数组元素的首地址，
而不是在原地址基础上加1

指针变量的加减运算只能对数组指针变量进行，对指向其他类型变量的指针变量做加减运算你是服务一一的

3. 两个指针变量之间的运算

只有指向同一个数组的两个指针变量之间才能进行运算 ，否则运算毫无意义

(1) 两指针变量相减

两指针变量相减所得之差是两个指针所指数组元素之间相差的元素个数

两个指针变量不能加法

（2） 两指针变量进行关系运算

指向同一数组的两个指针变量进行关系运算可以用来表示它们所指数组元素之间的关系

另外，指针变量还可以与0比较。设p为指针变量
p ==0; //表明p是空指针，它不指向任何变量
p!=0; // 表示p不是空指针

空指针是由对指针变量赋予0值而得到的

#define NULL 0

int *p =NULL;

对指针变量赋值0和不赋值是不同的。
指针变量未赋值时，可以是任意值，是不能使用的，否则将产生错误
而指针变量赋值0后，则可以使用，只是它不指向具体的变量而已


(3) 指针的算术运算
p += i;// 把p+i的值赋给p
p -=i; // 把p-i的值赋给p

p++;  //先取指针p指向的值，再将指针p自增1
p--; // 先取指针p指向的值，再将指针p自减1

9. 3 指针与一维数组

数组名代表数组的首地址

a=&a[0]的含义就是数组名代表数组的首地址

p=&a[0]; 
p=a;

两句是等价的

c语言规定，如果指针变量p指向数组中的一个元素，则p+1指向数组
的下一个元素，p-1指向数组的上一个元素


下标法，数组名法， 指针法

a[i] 与*(a+i)等价

9.4 指针与二维数组


1. 二维数组的地址

c语言允许把一个二维数组分解为多个一位数组来处理


2.二维数组元素的地址级引用

最常见的取a[i][j]的地址 &a[i][j]


与*(a+i)+j等价


由于a[i][j]与a[0][0]之间湘菜上4*i+j个元素(每行有4个元素)
因此，可以根据a[0][0]的地址，得到取元素a[i][j]地址的两种方式：
&a[0][0] + 4i+j;
a[0] + a*i+j

有5中取得二维数组元素地址的方式，在其地址前加上运算符"*"就能得到相应的元素值

1. *(&a[i][j])
2.*(a[i]j)
3.*(*(a+i)+j)
4. *(&a[0][0]+4*i+j)
5.*(a[0]+4i+j)

9.5 指针与字符串
1. 用字符数组存放一个字符串，然后输出该字符串
2. 用字符串指针指向一个字符串

也可以通过赋值运算使一个字符指针指向一个字符串常量


字符指针和字符数组的区别

实现字符串的存储和运算既可以使用字符串指针变量又可以使用字符数组
但二者是有区别的

1. 字符指针变量是一个变量，而数组名是一个地址常量，所以不能直接给一个数组名赋值

2.字符型指针变量的值是可以改变的
3. 进一步区分字符指针变量和字符数组在内存中的存储情形


9.6 指针与指针

在c语言中，数组元素全为指针的数组称为指针数组

一维指针数组 

类型名 *数组标识符[数组长度]
int *ptr_array[10]

9.6.3 指向另一个指针地址的只恨

一个指针变量指向另一个指针变量，如设i为整型变量，p为指针变量，pp为指向指针的指针变量

一般形式：类型标识符  **指针变量名；

指针质量的指针变量不仅仅局限于单个的指针Ibanez还可以是指针数组

char **p;
2.


一般的指针变量的引用使用是符号"*"  ,例如 *p1
而指向另一个指针地址的指针变量就是 **p1;

9. 7 指针与函数 
9.7.1  指针作为函数的参数


c语言中，为了使在函数中改变了的值能被main函数所用，应该用指针变量作为函数参数

程序是由函数构成的，函数表示处理，实参表示存储，函数的指针参量表示存储和处理的中介，
实参初始化形参，函数通过指针处理存储中的数据

指针的作用就是存储变量的地址值。
在主函数main中，将变量m,n的地址值传递给pm,pn,然后通过调用swapint函数将pm,pn的值传递给pa,pa
并实现交换，同时释放形参pa,pb，并输出最后的结果
在c语言中，为了使在函数中改变了的值能被main函数所用，应该用指针变量作为函数参数


9.7.2  一维数组名作为函数实参

因为数组名是一个地址值，可以把数组名传递给函数

数组名作为函数的参数，

1.如果订餐是数组形式，则实参必须是实际的数组名，如果实参是数组名，
则形参应该是指针或同样维书的数组名

2.要在主调函数和北调函数中分别定义数组

3.实参数组和形参数组必须类型相同，形参数组可以不指名长度

4.在c语言中，数组名除作为变量的标识符外，数组名还代表了该数组在内存中
的起始地址，因此，当数组名作函数参数时，实参与形参之间不是"值传递"，而是
“地址传递”，实参数组名将该数组的起始地址传递给形参数组，两个数组共享一段内存单元，
编译系统不再为形参数组分配存储单元


9.7.3 二维数组名作函数参数

二维数组名是一个地址值，所以可以把数组名传递给函数


9.7.4 字符指针做函数实参

用字符数组名或指向字符串的指针作为函数参数，可以实现字符串从主调函数
传递到北调函数的功能

9.7.5  返回指针的函数

一个函数不仅可以带回一个整型数据的值，字符类型值和实型类型的值，
还可以带回指针类型的数据，使其指向某个地址单元。
返回指针的函数就是，定义一个函数，该函数的返回值是一个指向某变量的指针

返回指针数据类型  *函数名(参数表)

int *fun(int a,int b) ;// 定义函数fun,接受两个整型的参数a,b,返回一个指向整型变量的指针

char *ch();  //表示的就是一个返回字符型指针的函数


9.7.6  函数指针

函数指针是指向函数的指针变量。因为首先"函数指针"本身应是指针变量，
正如用指针变量可以指向整型变量，字符型，数组一样，这里指向函数

c语言在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址
有了指向函数的指针变量后，可用该指针变量调用函数，如同用指针变量可引用其他类型变量一样
函数指针有两个用途：
1.调用函数
2.作为函数的参数


1. 函数指针的声明

返回值类型 (*指针变量名) (形参列表);

"返回值类型" 用于说明函数的返回类型
(指针变量名) 中额括号不能省，括号用于改变运算符的优先级。
若省略整体则称为一个函数说明，说明一个返回的数据类型是指针的函数；


"形参列表"表示指针变量指向的函数所带的参数列表


int (*fun)(int a,int b); //函数指针fun指向一个返回值是整型变量的函数，并且
这个函数接受两个整型的变量

2  函数指针的初始化


int func(int x);  // 声明一个函数
int (*f) (int x);  //声明一个函数指针
f = func; ;  将func函数的首地址赋值给指针f



3.函数指针引用

函数指针是通过函数名及有关参数进行调用的

与其他指针变量相似，如果指针变量pi是指向某整型变量i的指针，则*p等于它所指的变量i；
如果pf是指向某浮点型变量f的指针，则*pf就等价于它所指向的变量f.

*f 是指向函数func(x)的指针，则*f就代表它所指向的函数func.
所以在执行了f=func之后，(*f)和func代表同一函数


由于函数指针指向存储区中的某个函数，因此可以通过函数指针调用相应的函数。
如何用函数指针调用函数，
1. 要说明函数指针变量 ，例如，int (*f)(int x);
2. 要对函数指针变量赋值, 例如，f =func; // func(x)必须先要有定义
3. 要用(*指针变量)(参数表)，调用函数。  例如，(*f)(x);  //x必须先赋值

9.8 main函数中的参数

main函数是所有函数的入口，程序是从main函数开始的，也从这里结束

main函数可以带参数，也是main函数的形式采纳数

c语言规定main函数的参数只能有两个，
argc,argc

c语言规定，argc（第一个形参）必须是整型变量，
argv(第二个形参)必须是指向字符串的指针数组

加上形参说明后，main函数的函数头

main(argc,argv)
int argc;

char *argv[];


main (int argc, char *argv[])

{}


1. argc是一个整型参数，它用来存储命令行中的参数的个数
2. argv是一个指向字符串的指针数组。
它用来存储每个命令行参数，所以命令行参数都应该是字符串，
这些字符串的首地址就构成了一个指针数组

变量的指针，就是该变量的地址


指针间进行运算，变量间进行运算


int *p;
p就是为指针
*是指针命名符号
 & 取地址(取指针符号)
&p就是指针的指针
p =&n ; 就是取n的指针然后赋值p

第10章 编译预处理

宏定义和调用(不带参数的宏，带参数的宏)
文件包含预处理
条件编译


使用以"#"开头的预处理命令，如包含命令#include,宏定义命令#define
在源程序中这些命令都放在函数之外，而且一般都放在源文件的前面，称为预处理


预处理是指在进行编译的第一遍扫描(词法扫描和语法分析)之前所做的工作

预处理程序负责换成预处理工作

当对一个源文件进行编译时，系统将自动引用预处理程序对源程序中的预处理部分作处理，
处理完毕自动进入对源程序的编译


c源程序(无预处理命令) ---编译-->  目标程序 --->执行程序
c源程序(有预处理命令) ---编译-->  目标程序 --->执行程序

c语言提供了多种预处理功能，如宏定义，文件包含，条件编译等

合理的使用预处理功能有利于程序的阅读，修改，移植和调试， 也有利于模块的程序化设计


预处理命令的几个特点
1. 预处理命令均以"#"开头，结尾不加分号
2. 预处理命令可以放在程序中任何位置，作用范围从定义处到文件结尾


10.1  宏定义


宏定义即为替换思想。
在c语言源程序中允许用一个标识符来表示一个字符串，称为“宏”

在c语言中，"宏"分为有参数和无参数两种

1. 无参数宏定义

#define 宏名 宏体

(1) define为宏定义命令，宏名一般用大写字面表示，宏体可以是常数，表达式，格式串等

(2) 宏定义必须写在函数之外，其作用域为宏定义命令开始到源程序结束。
终止其作用域可用  #underf 宏名


#define PI 4646

main()
{}

#undef PI

sum()
{}

(3) 宏名在源程序中若用引号括起来，则预处理程序不对其做宏替代

#define OK 100

main()
{
printf("OK");}

(4) 宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名。
在宏展开时由预处理程序层层带环

#define PI 66
#define S PI *y *y


(5) 习惯上宏名用大写字面表示，以便于与变量区别，但也允许用小写字面
(6) 可用宏定义表示数据类型，使书写方便

#define STU int

(7) 对"输出格式"做宏定义，可减少书写麻烦

2. 带参数宏定义 

#define 宏名(形参表) 形参表达式

#define MAX(a,b) (a>b) ?(a):(b)

进行宏替换时，可以像使用函数一样，通过实参与形参传递数据

注意
1.宏名和括号之间不能有空格
2.宏低缓只做简单的替换
3.带参数的宏 和不带参数的宏的区别


在函数调用时，是先求出实参表达式的值，再传递给形参，而宏定义只是简单的字符替换
函数调用是在程序运行时处理的，分配存储单元，而宏展开(调用)是在编译预处理时进行的
展开时不分配内存单元，不进行值传递，没有返回值的概念

对函数实参和形参都要有定义类型，而宏不存在类型，宏定义时替换文本可以是任何类型的数据，
但在使用的过程中一律看做字符串。
宏名没有类型，只是用一个符号表示，展开时带入指定的文本即可

10.2 文件包含
"文件包含" 处理就是指在预编译时，用指定的文件内容替换文件包含命令

命令的一般形式为：

#include<文件名>
#include"文件名"


文件包含的几点说明：
1.使用格式1时，预处理程序在c编译系统定义的标准目录下查找指定的文件
2.使用格式2时，预处理程序首先在当前源文件所在目录下查找指定文件，如没找到，
则在c编译系统定义的标准目录下查找指定的文件
3.一个#include命令只能包含一个文件，而且必须是文本文件
4. 文件包含可以嵌套，即被包含文件中又包含另一个内文件


一个包中可以包含多个类，一个源文件中可以有多个类，但只能有一个公共类
在同一个包中的类在默认的情况下是可以相互访问的
一般情况下用package语句将源文件存入指定的包中，如果没有该语句，
则源文件存入当前目录下


可以把define定义为用户标识符，但不能把if定义为用户标识符
表达式没有调用函数，执行时默认最后一个表达式


第11 章 结构体，共同体和枚举类型

用typeof说明一个新类型
结构体和共用体类型数据的定义和成员的引用
通过结构体构成链表，单向链表的建立，结点数据的输出，删除与插入

11.1 结构体

结构体就是由不同类型的相关数据组成的集合

结构体是一个构造类型，是一种由用户自己定义的数据类型，用户根据需要，
构造相应的结构体类型。然后用户可以使用已经定义的结构体定义变量，数组，指针等


11.1.1 用typeof定义类型

c语言允许用typeof说明一种新类型名，
typedef 类型名 新类型名；

(1) typeof是用户定义类型的关键字
(2) 类型名必须是在此语句之前已经定义的类型标识符，可以是基本类型，构造类型，指针类型或自动以类型
(3) 新类型名 是用户自定义的类型名，可以是任意在c语言中合法的标识符，一般习惯用大写字母
(4) typedef语句的作用仅仅是用"新类型名"来代表已经存在的"类型名"，并未产生新的数据类型，
原有类型名依然有效，新类型名与原类型名可以同时使用

2. 为不同数据类型定义新类型名

(1) 为基本类型命名

typedef int E;
E i,j;

(2) 为数组类型命名

typedef char C[5];
C a,b[5]; //  char a[5], char b[5][5]

(3)  为指针类型命名

typedef int *I;
I ip;  // 相当于int *ip
I *PP; // 相当于 int **p


(4) 为函数指针类型命名

typedef int(* F)();
F funp;  //相当于 int (*funp)();

11.1.2  结构体类型说明

结构体由若干个不同类型的数据项组成，构成结构体的哥哥数据项称为结构体成员，
结构体类型说明的形式

struct 结构体名
{数据类型1 成员表1；
}

(1) struct是定义结构体类型的关键字，是结构体类型的标志
(2) 结构体名 是可选项，在说明中可以不出现。另外每个"成员表"内都可以包含有多个类型的成员，并用逗号隔开
(3) 同一结构体中，不能有相同名字的变量，但不同的结构体说明中成员可以同名，并且
结构体成员可以和程序中的其他变量同名


struct student
{
	char name[10];
	char sex;
	int age;
	float score;
}


11.1.3 结构体类型定义

1.先说明结构体类型，再定义结构体变量

struct 结构体名 变量名表；

struct student p1,s[30], *p2

2. 紧跟在结构体说明之后进行定义

struct student
{
	char name[12];
	char sex;
	float sc[4];
} std,pers[3],*pstd;

std 为结构体类型变量
pers[3] 为结构体类型数组
pstd为指向结构体类型的指针


3. 先说明结构体类型，再单独进行变量定义

struct student
{
	char name[12],sex;
	struct date birthday;
	float sc[4];
};
struct student std,per[3],*pstd;

4. 使用typedef说明结构体类型名，用新类型名定义变量

typedef struct
{
	char name[12] ,sex;
	float sc[4];
} STREC;
STREC std,per[3],*pstd;


11.14 结构体初始化

1. 给结构体变量赋初值

所赋值放在一对花括号里

struct student
{
	char name[12],sex;
	float sc[4];
} std = {"likang","b","16343"};

2. 给结构体数组赋初值

struct bookcard {
	char num[5],
	float money;
} bk[3] ={{"no,1",36},{"no.2",66},{"no.3",99}};

11.1.5  结构体的引用

1. 对结构体变量成员应用的三种方式
(1) 结构变量名.成员名  
(2) 指针变量名->成员名
(3) (*指针变量名).成员名


方式一中，点号称为成员运算符
方式二中，"->"称为结构指向运算符
方式三中，是通过一个结构体指针变量来引用它所指向的那个结构体变量的成员，一对圆括号是不可少的

成员运算符"."  结构指向运算符"->" 圆括号"()" 下标运算符"[]"的优先级相同，都是最高



struct student
{
	char name[12],sex;
	float sc[4];
} std,arr[5],*ps;
ps = &std;

(1) 若要引用结构体变量std中的sex成员
std.sex  // 通过结构体变量引用
ps -> // 通过指针变量引用
(*ps).sex //通过指针变量引用

(2) 若要引用结构体变量std中的数组成员sc中的元素sc[2] 
std.sc[2] 或　ps->sc[2] 或(*ps).sc[2]

(3) 若结构体变量中的成员是作为字符串使用的字符数组，如结构体中的成员name,其引用形式为

std.name 或ps-> name  或　(*ps).name

(4) 若要引用结构体变量std中内嵌成员
std.birthday.year 或 ps-> birthday.year 或　(*ps).birthday.year

３．　通过指针变量引用结构体成员应该注意运算符的优先级

 a.  ()[] -> .
ｂ.  ! ++ -- & sizeof
c．  */ % + -
d　　<< = >> ==
e  && ||
f  条件运算符
g  赋值运算符

11.1.6 结构体指针与函数
１．　向函数传递结构体变量的中的的那个成员数据
2. 向函数传递整个结构体变量中的数据
向函数传递结构体变量，传递的是实参结构体变各成员的值，函数中形参结构体变量的
改变不会影响到实参

３．　传递结构体变量的地址

将结构体变量的地址做为实参传递，对应的形参应该是一个基类型相同的结构体的指针变量

４．　向函数传递饥饿哦固体数组名

向函数传递结构体数名，传递的是实参结构体数组首地址，
函数中对应的形参应该是指向结构体的指针变量，
因此对数组进行的任何操作都会影响到实参结构体数组


5. 函数的返回值是结构体类型
6. 传递结构体的指针

将结构体变量的地址作为实参传递，这时对应的形参应该是一个基类型相同的结构体类型的指针。
系统只需为形参开辟一个存储单元存放实参结构体的地址值
而不必另行建立一个结构体变量

这样既可以减少系统操作需的时间，提高程序的执行效率，
又可以通过函数调用，有效的修改结构体中成员的值

11.2  动态内存分配




ｃ语言定义了４个内存空间：代码区，全局变量与静态变量，局部变量区(即栈区)，动态存储区(即堆区或自由存储区)

动态内存分配就是指在程序直接的过程中动态的分配或回收存储空间的分配内存的方法
动态内存分配不像数组等静态内存分配方法那样需要预先份额存储空间，而是由系统根据程序的需要即时分配，
且分配的大小就是程序要求的大小

１１．２１　动态存储分配

在c语言中，程序执行期间需要空间来存储数据是，通过"申请"分配指定的内存空间，
当内存空间闲置不用时，可以随时将其释放，由系统安排另作他用


与动态内存分配有关的函数 malloc,free,calloc,realloc
使用前，要在程序开头包含头文件"stdio.h"

1. malloc函数

malloc(size);

malloc函数的作用是向系统申请分配指定size个字节的内存空间，其中size的数据类型是unsigned int

函数的返回值是新分配的存储区的首地址，是一个void类型指针，若分配失败，则返回NULL(即０)


short in *pi;
float *pf;
pi = (short int*)malloc(2);
pf = (float*)malloc(4);


由动态分配得到的存储单元没有名字，只能通过指针变量来引用它。一旦指针改变指向，
原存储单元及所存数据都无法再引用。通过调用malloc函数所分配的动态存储单元中没有确定的初值

若不能确定数据类型所占字节数，可以使用sizeof运算符求得

pi = (short int*)malloc(sizof(short int));
pf = (float*)malloc(sizof(float));

这是一种常见形式，由系统计算指定类型的字节数


２．　free函数

在使用malloc函数分配内存空间后，一定要记得释放内存空间，否则就会出现内存泄露，
导致内存资源耗尽，程序无法运行

free函数释放的是指针指向的内存，而不是指针。
指针并没有被释放，仍然指向原来的存储空间。释放了内存空间后，原来指向这块空间的
指针指向的内容未定义的。
因此，释放内存后把指针指向NULL,防止指针在后面不小心又被引用

free(p);

函数调用时的实参p必须是一个指向动态分配存储区的指针，它可以是任何类型的
指针变量，此函数无返回值

此函数通过释放指针p所指向的动态内存区使这部分空间可以由系统重新分配


pi = (int *)malloc(sizeof(int)); // 分配sizeof(int) 个字节的存储区
free(pi);  // 释放该存储区


calloc函数　　calloc(n,size);

此函数在内存中动态分配一个n * size字节的存储区，其中n和size的数据类型都是unsigned int

此函数返回值为新分配的存储区的首地址，是一个void类型指针，若分配失效，
则返回NULL,由于该函数返回的指针为void*(无值型)，故在调用函数时，必须使用强制类型转换
将其转换成所需的类型


int *int;
pi = (int *)calloc(10,sizeof(int)); // 动态分配了10个存放整型数据的存储单元，
并将指针pi指向该存储单元的首地址

１１．２．２　动态链表


c语言在执行动态分配存储单元时，其地址不可能是连续的，而所需处理的批量数据往往是贵整体，各数据之间存在着接序
关系，此时我们可以利用链表这样的存储结构来反映出数据之间的相互联系

在链表的每个结点中，除了要有存放数据本身的数据域外，至少还需要有一个指针域，用它来存放
下一个结点元素的地址，以便通过这些指针把各结点连接起来，从而形成链表

head(头指针)---> 头结点---> NULL

单向链表的结构有：

１．头指针变量head,尾指针NULL
2. 每个节点由两个域组成，即数据域和指针域


１１．２．３　利用结构体变量构成链表

１．链表节点结构的定义

ｃ语言中，定义链表节点结构的形式

struct 结构体名
{
	结构成员表
	struct 结构体名　* 指针变量名；
	};

上面为引用自身的结构体

struct node
{
	int data;
struct node *next;
}a;

上面定义的结构体类型node共有两个成员：成员data是整型，struct是一个可以指向struct node 
类型变量的指针。这种情况下，a.next=&a 是合法的表达式，

２．　链表的基本操作

对链表的基本操作包括链表的创建，增加，删除节点，链表的逆序，排序和销毁等

(1) 链表的常见
读取数据；　生成新节点；　将数据存入节点的成员变量中；　将新结点添加到链表中；　重复上述操作直至输入结束

(2) 链表的删除

从链表中删除结点，就是撤销结点在链表中的链接，把结点从链表中孤立出来。
从链表中删除节点一般有两个过程：
1.把指定的结点从链表中拿下来，它需要通过修改有关结点的指针域来完成
２．　释放该结点使用的内存空间，它需要使用free()函数来完成

(3) 链表的插入

在单向链表中插入结点
1.首先要确定插入的位置
２．当插入的结点在指针的结点之前称为"前插"
３．当插入的结点在指针的结点之后称为"后插"
４．当进行"前插"操作时，需要３个工作指针(假设s1,s2,s3)
用s1来指向新开辟的结点
用s2指向插入的位置
用s3指向s2的前驱结点

在链表值为a的结点前插入b结点

在空链表中插入一个结点

空链表就是头指针为空的链表，链表为空表这种情况，新结点应插在表尾，即插在头结点之后，
作为表的第一个结点
在查找到链表的a结点的前面插入结点
若a结点不存在，则及诶按插在表尾



(4) 链表的查找

链表的查找是根据给定的条件查找某个结点。通常的方法是顺序访问链表中各结点的
数据域，查找满足条件的结点。
在链表中进行查找，就是从链表的第一个结点开始，沿着指针链，用查找值与链表结点
逐个比较的过程。找到符合要求的结点之后，停止查找过程，返回相应的结点指针，否则会返回一个空指针


１１．３　共同体

１１３．１共同体的含义与定义方法

1.含义

c语言提供了一种由若干个不同类型的数据项目组成，但共享同一存储空间的构造类型。
在不同的时刻能够把不同类型的数据存放到相同的内存单元中，这种构造的数据类型为共同体

union 共用体名
{
	成员表列;}
变量表列;

union date
{
int i;
char ch;
float f;} a,b,c;



共同体有３中引用方式

共用体变量名.成员名
指针变量名 ->成员名
(*指针变量名).成员名


union date
{
int i;
char ch;
float f;} a,b,c,i.a;


union date
{
int i;
char ch;
float;}a,b,c,ps ->a;

union date
{
int i;
char ch;
float f;} a,b,c,(*ps).a'

11.4 枚举类型

枚举用于声明一组命名的函数，当一个变量有几种可能的取值时，可以将它定义为枚举类型

"枚举类型"是将变量的取值－－列举出来，变量的取值只限于在列出来的取值范围

２．定义方法

enum season{spring,summer,autumn,winter};
enum season a;
枚举类型的变量a的取值就只有４个

枚举元素在c语言中按常理来处理，不是变量，不嗯给你被赋值
作为常量的枚举元素，它们是有值的。在编译是按它们的定义顺序取值为0,1,2等
也可以在定义类型时人为定义枚举元素的值

枚举值可以用啦做条件判断
if(a==summer)
if(a>true)

一个整数不能直接赋值给一个枚举变量

w = (enum a) 3;

结构体变量，结构体变量名

当定义一个结构体变量时，系统为它分配的内存空间为结构中各成员所需内存容量之和，malloc



第１２章　位运算（嵌入式用的多！）

位运算是值安二进制位尽心的运算


按位与　&
按位或　　｜
“异或”　^

"取反"运算符　~
左移运算符　<<
右移运算符　>>
第１３章　文件

文件类型指针(FILE类型指针)的作用
文件的打开与关闭(fopen,fclose)
文件的读写(fputc,fgetc,fputs,fgets,fread,fwrite,fprintf,fscanf函数的应用)
文件的定位(rewind,fseek函数的应用)

１３．１　文件概述

文件操作有库函数来完成

文件分为ASCII码文件和二进制码文件

按编译系统对文件的方式划分可分为缓冲文件系统和非缓冲系统

或顺序存取文件和直接存取文件

FILE *变量名表；

FILE *fopen("文件名"',"操作方式")；

fclose(文件指针);

fgetc(文件指针);

fputc(字符数据，文件指针);

fread(buffer,size,count,fp);

fwrite(buffer,size,count,fp);

